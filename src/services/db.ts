
import * as Sequelize from 'sequelize'

export type Model<TInstance, TAttribute> = Sequelize.Model<TInstance, TAttribute>
export type Models = Sequelize.Models
export type Instance<TAttribute> = Sequelize.Instance<TAttribute>

import { create } from 'services/logger'
const log = create('db')

const env = process.env.NODE_ENV || 'development'
import { config as Config } from 'config'
const config = Config.sequelize[env]

const createSequelize = (config: any) => {
  const logging = Config.sequelize.logLevel
    ? (sql: string) => log[Config.sequelize.logLevel as any](sql)
    : false
  const sequelizeConfig: Sequelize.Options = {
    logging,
  }
  if (config.use_env_variable) {
    log(`creating from env: ${process.env[config.use_env_variable]}`)
    return new Sequelize(process.env[config.use_env_variable], sequelizeConfig)
  } else {
    log(`creating from config`)
    return new Sequelize(config.database, config.username, config.password, sequelizeConfig)
  }
}

export interface Node {
  id: string
  createdAt: Date
  updatedAt: Date
}

export interface DataAttributes extends Sequelize.DefineAttributeColumnOptions {
  allowUpdates?: boolean
}

export type SequelizeAttributes<Attributes extends { [key: string]: any }> = {
  [Key in keyof Attributes]: string | DataTypeAbstract | DataAttributes
}

export interface SequelizeAttributeType<Attr, Inst extends Instance<Attr>> extends DataAttributes {
  _autoGenerated: boolean
  _modelAttribute: boolean
  allowNull: boolean
  autoIncrement: boolean
  comment: string
  field: string
  unique: boolean
  defaultValue: (args: any[]) => any
  fieldName: string
  Model: Model<Inst & Attr, Attr>
  primaryKey: boolean
  type: DataTypes
}

export type ModelAttributes<Attr, Inst extends Instance<Attr>> = Record<string, SequelizeAttributeType<Attr, Inst>>

export const getModelAttributes = <Attr, Inst extends Instance<Attr>>(
  model: Model<Inst & Attr, Attr>,
) => (model as any).attributes as ModelAttributes<Attr, Inst>

export const getModelAssociations = <Attr, Inst extends Instance<Attr>>(
  model: Model<Inst & Attr, Attr>,
) => (model as any).associations as ModelAttributes<Attr, Inst>


export { Sequelize }
export const sequelize = createSequelize(config)

export type DataTypes =
  | DataTypeAbstract
  | DataTypeArray
  | DataTypeBigInt
  | DataTypeBlob
  | DataTypeBoolean
  | DataTypeChar
  | DataTypeDate
  | DataTypeDateOnly
  | DataTypeDecimal
  | DataTypeDouble
  | DataTypeEnum
  | DataTypeFloat
  | DataTypeGeometry
  | DataTypeHStore
  | DataTypeInteger
  | DataTypeJSONB
  | DataTypeJSONType
  | DataTypeMediumInt
  | DataTypeNow
  | DataTypeNumber
  | DataTypeRange
  | DataTypeReal
  | DataTypeSmallInt
  | DataTypeString
  | DataTypeText
  | DataTypeTime
  | DataTypeTinyInt
  | DataTypeUUID
  | DataTypeUUIDv1
  | DataTypeUUIDv4
  | DataTypeVirtual

export type DataTypeAnyFloat =
  | DataTypeFloat
  | DataTypeDouble
  | DataTypeReal

export type DataTypeAnyInteger =
  | DataTypeNumber
  | DataTypeTinyInt
  | DataTypeSmallInt
  | DataTypeMediumInt
  | DataTypeInteger

export type DataTypeAnyNumber =
  | DataTypeAnyFloat
  | DataTypeAnyInteger

export type DataTypeAnyString =
  | DataTypeChar
  | DataTypeString
  | DataTypeText
  | DataTypeBigInt // need to be stored as string
  | DataTypeDecimal // need to be stored as string

export type DataTypeAnyDate =
  | DataTypeDate
  | DataTypeDateOnly
  | DataTypeTime

export type DataTypeScalar =
  | DataTypeAnyNumber
  | DataTypeAnyString
  | DataTypeAnyDate
  | DataTypeUUID
  | DataTypeBoolean

export interface DataTypeAbstract {
  dialectTypes: string
  toSql: () => string
  stringify: () => string
  key: string
}
export interface DataTypeAbstractString extends DataTypeAbstract {
  options: { binary: boolean, length: number }
  _binary: boolean
  _length: number
}
export interface DataTypeBasicAbstract extends DataTypeAbstract {
  key: 'ABSTRACT'
}
export interface DataTypeString extends DataTypeAbstractString {
  key: 'STRING'
}
export interface DataTypeChar extends DataTypeAbstractString {
  key: 'CHAR'
}
export interface DataTypeText extends DataTypeAbstractString {
  key: 'TEXT'
  _binary: never
  validate: (value: string) => boolean
}
export interface DataTypeAbstractNumberOptions {
  length: number
  zerofill: boolean
  decimals: number
  precision: number
  scale: number
  unsigned: boolean
}
export interface DataTypeAbstractNumber extends DataTypeAbstract {
  options: DataTypeAbstractNumberOptions
  _length: number
  _zerofill: boolean
  _decimals: number
  _precision: number
  _scale: number
  _unsigned: boolean
}
export interface DataTypeNumber extends DataTypeAbstractNumber {
  key: 'NUMBER'
}
export interface DataTypeTinyInt extends DataTypeAbstractNumber {
  key: 'TINYINT'
}
export interface DataTypeSmallInt extends DataTypeAbstractNumber {
  key: 'SMALLINT'
}
export interface DataTypeMediumInt extends DataTypeAbstractNumber {
  key: 'MEDIUMINT'
}
export interface DataTypeInteger extends DataTypeAbstractNumber {
  key: 'INTEGER'
}
export interface DataTypeBigInt extends DataTypeAbstractNumber {
  key: 'BIGINT'
}
export interface DataTypeFloat extends DataTypeAbstractNumber {
  key: 'FLOAT'
}
export interface DataTypeTime extends DataTypeAbstract {
  key: 'TIME'
}
export interface DataTypeDate extends DataTypeAbstract {
  key: 'DATE'
}
export interface DataTypeDateOnly extends DataTypeAbstract {
  key: 'DATEONLY'
}
export interface DataTypeBoolean extends DataTypeAbstract {
  key: 'BOOLEAN'
}
export interface DataTypeNow extends DataTypeAbstract {
  key: 'NOW'
}
export interface DataTypeBlob extends DataTypeAbstract {
  key: 'BLOB'
}
export interface DataTypeDecimal extends DataTypeAbstract {
  key: 'DECIMAL'
}
export interface DataTypeDecimal extends DataTypeAbstract {
  key: 'DECIMAL'
}
export interface DataTypeUUID extends DataTypeAbstract {
  key: 'UUID'
}
export interface DataTypeUUIDv1 extends DataTypeAbstract {
  key: 'UUIDV1'
}
export interface DataTypeUUIDv4 extends DataTypeAbstract {
  key: 'UUIDV4'
}
export interface DataTypeHStore extends DataTypeAbstract {
  key: 'HSTORE'
}
export interface DataTypeJSONType extends DataTypeAbstract {
  key: 'JSONTYPE'
}
export interface DataTypeJSONB extends DataTypeAbstract {
  key: 'JSONB'
}
export interface DataTypeVirtual extends DataTypeAbstract {
  key: 'VIRTUAL'
}
export interface DataTypeArray<DataType = DataTypeAbstract> extends DataTypeAbstract {
  key: 'ARRAY'
  type: DataType
}
export interface DataTypeVirtual<ReturnType = DataTypeAbstract> extends DataTypeAbstract {
  key: 'VIRTUAL'
  returnType: ReturnType
  fields: Record<string, DataTypeAbstract>
}
export interface DataTypeEnum<DataType = DataTypeAbstract> extends DataTypeAbstract {
  key: 'ENUM'
  values: DataType[]
  validate: (value: any) => boolean
}

export type RangeSubTypes = 'integer' | 'bigint' | 'decimal' | 'dateonly' | 'date' | 'datenotz'
export interface DataTypeRange<DataType extends RangeSubTypes = 'integer'> extends DataTypeAbstract {
  key: 'RANGE'
  _subtype: DataType
  options: { subtype: DataType }
}
export interface DataTypeReal extends DataTypeAbstract {
  key: 'REAL'
}
export interface DataTypeDouble extends DataTypeAbstract {
  key: 'DOUBLE'
}
export interface DataTypeDouble extends DataTypeAbstract {
  key: 'DOUBLE'
}
export interface DataTypeGeometry extends DataTypeAbstract {
  key: 'GEOMETRY'
}
